<h1 id="top">Зомбоид документација</h1>
 <p>Zomboid е дводимензионална видеоигра од типот платформер создадена во стилот на 8-бит видеоигрите од третата генерација на игри, популаризирани во 1980тите години.
Целта на играта е успешно да се пренесе последниот жив човек на земјата од една до друга страна на град полн со зомбиња.
Корисникот е снабден со безконечно количество на куршуми и три шанси за преживување претставени како мали срца лоцирани во левиот дел од екранот.
Доколку се дојде во контакт со зомбињата, корисникот губи една шанса за преживување. Откако корисникот ќе ги изгуби сите три срца, играта се ресетира.</p>


[[_TOC_]]


<h2 id="how-to-compile">Компајлирање на проектот</h2>
<p>Линкови до потребните фајлови (<a href="https://www.libsdl.org/download-2.0.php">SDL2</a>,  
 <a href="https://www.libsdl.org/projects/SDL_image/">SDL_image</a>,  
 <a href="https://www.libsdl.org/projects/SDL_ttf/">SDL_ttf</a>,  
 <a href="https://www.libsdl.org/projects/SDL_mixer/">SDL_mixer</a>).</p>
<p>За да се компајлира кодот потребен ви е CodeBlocks со mingw компајлер, SDL 2.0  и три SDL екстензии (SDL_image, SDL_ttf и SDL_mixer). Потребно е да се симнат mingw-development верзиите за четирите наведени библиотеки (терба да се со понова или иста верзија како 2.0). Треба да се ископираат include и lib фолдерите кои што се наоѓаат во i686-w64-mingw32 фолдерот на четирите библиотеки и да се стават во нов фолдер наречен SDL2. По завршување на овие чекори SDL2 фолдерот треба да има само 2 фолдери наречени include и lib. Следен чекор е да се отвори CodeBlocks, да се оди settings->compiler->search directories исто како на сликата наведена подолу. Во compiler табот треба да се стави локацијата на SDL2 фолдерот и неговиот include подфолдер. Потоа во табот linker што се наоѓа до compiler да се стави локацијата на lib фолдерот.
</p>


![include](uploads/ed2f7ece2446575aa3a61e9c85993b2c/include.PNG)

<p>Последниот чекор е да се отвори табот linker settings да се поврзат библиотеките. Потребно е само да се ископира текстот (-lmingw32
-lopengl32 -lSDL2main -lSDL2 -lSDL2_image -lSDL2_ttf -lSDL2_mixer) во other linker options како што е наведено на сликата.
</p>

![linker](uploads/e0eca05ac24ba319be0b3ef8c2ee3634/linker.PNG)

[Back to top](#top)

<h2 id="extensions">Екстензиите на SDL</h2>
<p>SDL има многу библиотеки кои што му овозможуваат додатни функционалности, како на пример да се  додадат звуци, различни формати на слики, мрежно поврзување и.т.н. Во овој проект користевме три такви библиотеки :</p>

* **SDL_image** е библиотека за вчитување на различни формати на слики и ги вметнува како SDL површини и текстури.
* **SDL_mixer** е библиотека за вчитување на аудио. Ја користевме во нашиот проект за да вметнеме музика и звучни ефекти.
* **SDL_ttf** е библиотека која што овозможува да се генерираат површини од true type fonts. Библиотеката овозможува прикажување на текст на екранот.

[Back to top](#top)

<h2 id="Core">Основата на играта</h2>
<p>Основата на играта се наоѓа во фолдерот наречен Core. Тука се сите класи и функции задолжени за приказ на звук, слика, инпут од играчот, анимации, менаџмент на сцени и некои други логички функции во играта. Класите во овој фолдер, како и во останатиот дел од кодот за играта се поделени на .h и .cpp фајлови. Фајловите .h претставуваат хедери, каде што ја дефинираме нашата класа и ги дефинираме функциите, а во фајловите .cpp ги иницијализираме функциите од хедерите. Во суштина сето тоа во core фолдерот претставува game engine-от врз кој што ја градевме нашата игра.</p>

<h4 id="1">Звук</h4>

<p>Во нашиот проект користиме два типа на звук, односно два типа на фајлови за звук (.ogg и .wav). Значи имаме музика што е пуштена во позадина која што цело време свири (тоа е .оgg фајлот), и имаме звучни ефекти кои што се .wav . За да се вчитаат фајловите ги користиме функциите во класите (<b>Audio, Music и Sound</b>). Music и Sound се потомци на класата Audio. <b>Music</b> ја користиме за да вметнеме музика, додека пак <b>Sound</b> се користи за звучните ефекти. </p>

<h4 id="2">Слика</h4>

<p>Главната класа за прикажување слики на екранот е класата <b>Graphics</b>. Оваа класа ја користиме да создадеме прозорец преку кој што ќе се игра играта. Класата ја користиме да дефинираме со кои димензии ќе биде програмта, дали да биде fullscreen и ја користиме за да го дефинираме насловот на прозорецот. <br>
Сликите што ги користиме во нашиот проект се од типот .BMP, но со вметнувањето на SDL_image библиотеката можеме да вметнеме и други формати. Класата <b>Image</b> ја користи оваа библиотека и ни овозможува да вчитаме и да прикажеме слика на екран. Бидејќи сликите што ги користиме се од формат .BMP кој што не поддржува транспарентност, место транспарентност ја ставаме розевата боја (rgb:255,0,255) и класата <b>Image</b> кога ги вчитува сликите на местото на таа боја прави да е транспарентно. </p>


<h4 id="3">Анимации</h4>

<p>Со цел да прикажеме анимации на карактерите во играта имаме една слика во која што се комбинирани сите движења на карактерот. За да се прикаже движење ја делиме сликата на повеќе делови со еднаква висина и ширина, потоа  ги прикажуваме по некој редослед (на пример прикажаната слика би ја поделиле на 4 делови и би ја прикажале по редослед 4,3,2,1).</p>

![animation](uploads/e3233a1a9eb54f7e6058a54ead5a9891/animation.PNG)

<p>За прикажување анимации на карактерите ја користиме класата <b>Sprite</b>. Класата sprite ја користи класа Image со цел да вчита сликa, потоа во функцијата нагласуваме колку е висината и ширината на секоја слика од анимацијата (односно на колку делови треба да ја подели дадената слика).</p>

<h4 id="4">Инпут</h4>

<p>Класата <b>Input</b>  ја користиме со цел да провериме инпут од тастатурата и глувчето, односно кое копче е кликнато и како да ги добиеме координатите на кои што ни се наоѓа покажувачот.</p>

<h4 id="5">Сцени</h4>

<p>Класите <b> GameState </b> и <b> StateManager </b> ни овозможуваат да имаме повеќе таканаречени сцени во играта (Пример за сцена е main menu екранот, или едно ниво од играта). Класата  <b> GameState </b> ни претставува основа, односно една сцена. Покрај таа класа класата <b> StateManager </b> ни овозможува да промениме сцена, на пример да одиме од main menu во првото ниво, или пак да пријдеме на help екранот. Класата <b> StateManager </b> претставува дата структура од типот stack и користи инстанци од класата GameState како свои елементи. </p>

<h4 id="6">Тile мапи</h4>

<p>Tile мапата го дели нивото на мрежа од квадрати. За квадратите се дефинира ширина и висина. Tile мапите исто така се користат за да се цртаат елементи од нивото (како на пример коцките во играта супер марио). Во нашата игра со помош на tile maps, ги нацртавме колите и автобусот во нивото. Класата која што имплементира Tile мапи во нашиот проект е наречена <b>Map</b>. Map класата вчитува една слика која што ја дели на мрежа како наведеното:</p>

![TileMap](uploads/f173d330cfbcda10be385c74746a5a6b/TileMap.PNG)

<p>Сите коцки од сликата се именувани со бројка (почнувајќи од 1), која што потоа се користи понатаму за да се дефинира каде да се нацрта.<br>
Во нашиот проект користевме "custom" фајл наречен level1.map во кој што дефиниравме големина и ширина на мрежата, големина и ширина на коцките од горенаведената слика и наведовме точно каде да се нацртаат тие елементи. Додатно дефинираме кои коцки од мапата ќе се цврсти (solid) со цел да имплементираме колизија понатаму. <b>Map</b> класата користејќи fstream ги чита информациите од тој фајл и ги вметнува во играта.</p>

<h4 id="7">Елементи во сцената и колизија</h4>
<p>Погоре наведовме со кои класи ги менаџираме сцените, следува со кои класи ги вметнуваме колизијата и објектите во сцената (под објекти спаѓаат на пример играчот како и непријателите во нивото). Класите <b>Scene, SceneNode и MapNode</b> ги користиме за оваа цел.  Класата <b>Scene</b> претставува поврзана листа од повеќе <b>SceneNodes</b>. Во нашиот проект пример едно ниво би било една инстанца од класата Scene, додека пак непријател би бил претставен како еден SceneNode во Scene листата. Класата <b>MapNode</b> ни овозможува да имплементираме колизија помеѓу играчот и мапата, како и помеѓу другите елементи и мапата. </p>

[Back to top](#top)

<h2 id="scene">Менаџирање на сцените</h2>

<p>Во нашата игра имаме шест сцени. Промената помеѓу овие сцени ни овозможува да имаме класичен тип на игра со менија, едно ниво, начин да се паузира, посебен екран при завршување на нивото и.т.н.<br>
Сцените во нашиот проект се класите: </p>


<h4>MainMenuState</h4>
<p>Оваа класа е првата во стекот на State менаџерот. Таа го прикажува главното мени кое што го пречекува играчот при отварање на играта. Ни овозможува пристап до нивото и екранот за помош. </p>

<h4>CreditsState</h4>
<p>Оваа класа претставува екранот за помош, односно ни ги прикажува контролите за играта и ни овозможува да се вратиме на главното мени при клик на space копчето. </p>

<h4>RunState</h4>
<p>RunState е главната класа за играта. Таа го прикажува нивото и ја врши цела логика за играта. Преку нејзе може да се пристапи до PauseState, GameOverState и GameEndingState.

<h4>PauseState</h4>
<p>PauseState ни овозможува да ја паузираме играта сред нивото. Сред нивото ако се притисне копчето escape, се повикува оваа класа и се прикажува pause екранот. Сред екранот за пауза имаме две опции, да го кликнеме continue копчето ( не навраќа на RunState класата и продолжува играта ) или да го кликнеме exit копчето кое што ја гаси играта.</p>

<h4>GameOverState</h4>
<p>Кога играчот ќе ги изгуби трите животи, се повикува оваа класа. GameOverState го прикажува GameOver екранот и ни дава опција да се вратиме на главното мени. </p>

<h4>GameEndingState</h4>
<p>Кога играчот ќе стигне до крајот на нивото (најдесниот дел од нивото) се повикува оваа класа. GameEndingState го пракажува "congratulations" екранот и ни дава опција да се вратиме на главното мени. </p>

[Back to top](#top)

<h2 id="objects">Создавање објекти во светот</h2>
<p><b>EntityFactory</b> е класата задолжена со популирање на светот. Таа креира инстанци од класите PlayerEntity (класата што го создава играчот), ZombieWalker (класата што создава непријатели односно зомбиња), BulletEntity (класата што создава куршуми) и ExplosionEntity (класата што ги создава експлозиите при уништување на зомбињата).</p>

[Back to top](#top)

<h2 id="player">Играчот</h2>
<p><b>Player и PlayerEntity</b> се класите кои што ги користиме за да го прикажеме играчот и HUD-от ( правоаголникот со живот и срцињата). Player класата е должна за цртање на животите и правоаголникот со животот на играчот кој што се наоѓа во горниот лев ќош. PlayerEntity класата ги врши сите логички функции за играчот, односно проверува инпут за движење и пукање, ја врши логиката за животите (ако ги изгуби сите 3 да се ресетира) и тука ги повикуваме функциите за цртање и анимирање на играчот. </p>

 [Back to top](#top)

<h2 id="enemy">Непријатели</h2>
<p>Во нашата игра има само еден тип на непријател, тоа е зомбито. Класата <b>ZombieWalker</b> ни ја врши целата логика за зомбињата. Тука користиме функции за цртање и анимирање на зомбињата, како и функции за проверка дали има колизија помеѓу играчот и зомбито, во кој случај зомбито се уништува, а играчот губи живот. Зомбито се движи на една страна се додека не наиде на цврст (solid) дел од tile мапата, при што тој се врти на другата страна и продолжува додека не се случи истото.</p>

[Back to top](#top)

 <h2>Цртање на сликите користени во играта</h2>
 <p>Цртежот кој е назначен како позадина на нивото, анимациите на карактерот,кој е контролиран од играчот и анимациите на зомбињата се направени во програма наречена Asperite.<br>
Програмата е наменета за 2Д илустрација и анимација на проекти и игри со мала резолуција, како 8-бит видеоигрите. Самата програма нуди и можност за мапирање на свои Tile Maps и таа функција е искористена при создавање на позадинските елементи, како возилата.</p>
[Back to top](#top)
